ac.accessCarPhysics(): ac.StateCphysCarData
ac.addForce(position: vec3, posLocal: boolean, force: vec3, forceLocal: boolean)
ac.setColliderOffset(index: integer, offset: vec3): boolean // Returns `false` if there is no such collider.
ac.setWingGain(wingIndex: integer, cdGain: number, clGain: number)
ac.setGearsFinalRatio(finalRatio: number)
ac.setGearsGrinding(grinding: boolean)
ac.setDrivetrainDamageRPMWindow(newValue: number)
ac.setDrivetrainAWDFrontShare(frontShare: number)
ac.setAntirollBars(kFront: number, kRear: number)
ac.setEngineRPM(newValue: number)
ac.setEngineLifeLeft(newValue: number)
ac.setEngineStalling(value: boolean)
ac.setTyreInflation(tyre: integer, inflation: number)
ac.getTurboUserWastegate(index: integer): number
ac.setTurboUserWastegate(index: integer, value: number)
ac.setTurboMaxBoost(index: integer, value: number)
ac.setTurboWastegate(index: integer, wastegate: number, isAdjustable: boolean)
ac.setTurboExtras(index: integer, lagUp: number, lagDown: number, referenceRpm: number, gamma: number)
ac.overrideTurboBoost(index: integer, newBoost: number)
ac.getScriptSetupValue(id: string): refnumber
ac.setScriptSetupValue(id: string, value: number): boolean // Returns `false` if there is no such item
ac.getDynamicController(name: string): refnumber

struct ac.StateCphysWheelData {
	float angularSpeed;
	float slip;
	float slipAngle; // Slip angle in radians
	float slipRatio;
	float ndSlip;
	float load;
	float inflation; // For changing use `ac.setTyreInflation(tyreIndex, pressure)`
}

struct ac.StateCphysCarData {
	int inputMethod;
	vec3 gForces;
	vec3 localAngularVelocity;
	vec3 localVelocity; // Car velocity relative to car
	float damageLevel[4];
	float speedKmh;
	float ffb;
	float rpm; // For changing use `ac.setEngineRPM()`
	float engineLifeLeft; // For changing use `ac.setEngineLifeLeft()`
	float drivetrainDamageRPMWindow; // For changing use `ac.setDrivetrainDamageRPMWindow()`
	float drivetrainOriginalRPMWindow;
	float antirollBarFront;
	float antirollBarRear;
	float gearsFinalRatio;
	int absMode;
	int tractionControlMode;
	int gear;
	bool tractionControlInAction;
	bool areControlsLocked;
	bool isEngineStallEnabled; // For changing use `ac.setEngineStalling()`
	bool isBlackFlagged;
	bool enforceCustomInputScheme; // If set to `true`, use custom input scheme even if input method is not wheel (if not possible, disable input entirely)
	bool isGearGrinding; // For changing use `ac.setGearsGrinding()`
	float gas; // Can be changed (unless controls are locked or car has black flag)
	float brake; // Can be changed (unless controls are locked or car has black flag)
	float steer; // Can be changed (unless controls are locked or car has black flag)
	float clutch; // Can be changed (unless controls are locked or car has black flag)
	float handbrake; // Can be changed (unless controls are locked or car has black flag)
	int requestedGearIndex; // Can be changed (unless controls are locked or car has black flag)
	bool gearUp; // Can be changed (unless controls are locked or car has black flag)
	bool gearDown; // Can be changed (unless controls are locked or car has black flag)
	bool isShifterSupported; // Can be changed (unless controls are locked or car has black flag)
	float controllerInputs[8]; // Set values here and access them as SCRIPT_0...SCRIPT_7 inputs in dynamic controllers. For emissives and such, can be accessed as CPHYS_SCRIPT_0..., other Lua scripts can access via car physics state.
	state_cphys_wheel_data wheels[4];
}